Est ce que tu peux m'aider, tu vois je me prepare a creer une base de donnes, et je veux preparer les pages a celui ci, je veux que dans le code suivant, les donnees, n'importe la quelle que ce soit du const soit du JSX (Je parle de donnees comme <p>20%</p>, etc.... sauf les textes pour le design), je veux qu'il soit tous stocker dans des const mais, structurer comme si c'etait un json venant d'un backend, avec des id, etc.... je te laisse imaginer ce que tu dois faire, je compte sur toi, et avant de donnees le code dit moi ce que tu vas faire, dit moi ce que tu trouve qui devrai etre des donnees venants de la base de donnees



Est ce que tu peux m'aider, tu vois je me prepare a creer une base de donnes, et je veux preparer les pages a celui ci, je veux que dans le code suivant, les donnees, n'importe la quelle que ce soit du const soit du JSX (Je parle de donnees comme<p>20%</p>, calcule
, etc.... sauf les textes pour le design), je veux qu'il soit tous stocker dans des const mais, structurer comme si c'etait un json venant d'un backend, avec des id, etc.... je te laisse imaginer ce que tu dois faire, je compte sur toi, et avant de donnees le code dit moi ce que tu vas faire, dit moi ce que tu trouve qui devrai etre des donnees venants de la base de donnees


Je veux que tu verifie les codes, que tu me dise ce qui manque a l'autre pour que l'autre puisse l'utiliser pour afficher de vrai donnees ?

schema doit etre utiliser par la page



Je veux que tu analyse les codes, et sache que schema est deja utiliser autre part (c'est la base du backend et frontend), ce qu'on peu faire dans schema c'est ajouter des colomn, ajoutes des tables, mais en aucun cas supprimer des colomn, ou des tables.

Dans le fichier en join se trouve un page, ce page je veux qu'il utilise schema, donc restructures les deux code la page et schema pour qu'il s'utilise mutuellement, et les informations affichers dans la page ne doit pas etre perdu, et aussi dynamique, comme si c'etait vraiment logique, je veux que tu me donne le code complet des 2 corrigers, et utiliser des commentaires dans chacun pour voir les informations modifier et aussi, dans schema n'oublie pas dire ce que peu contenir un champ ou ce que fait un tables 












Je veux que tu analyse les codes, et sache que schema est deja utiliser autre part (c'est la base du backend et frontend), ce qu'on peu faire dans schema c'est ajouter des colomn, ajoutes des tables, utiliser le colomn deja dedans , mais en aucun cas supprimer des colomn, ou des tables.

Dans le code pour page, il y a des donnees, bien en const qu'en jsx dure (Si les donnees peuve deja etre gerer par la structure actuel tu dit), ne te confie pas au structure de donnees de la page pour construire le schema tu dois penser comme un pro de la base de donnees concepteur, je veux que tu adapte schema pour que le schema puisse le servire completement, donc tu dois me donnees le code complet de schema, meme avec ce qui reste inchanger (pour copie coller), avec une nouvelle version que la page puisse utiliser dans le future, n'oublie pas de mettre les commentaire pour savoir ce que tu as modifier et met un identifiant que schema a ete modifier pour la page X

Et la structure des donnees doit etres comme si un pro avait fait la conception (reflechi bien a quoi ressemble une diagramme de classe avant de donnees le code) de la base de donnees, et sache que le schema sera aussi utiliser pour generer un diagramme de classe dans le future alors je compte sur toi, avant de donnees le code dit moi ce que tu as compris de ma demande, et dit moi ce que va faire



Merci, fait de meme mais pour cette page en join et le code que tu as fourni









donne le code complet de schema fusionner






GROK 

Je veux que tu analyse les codes, et sache que schema est deja utiliser autre part (c'est la base du backend et frontend), ce qu'on peu faire dans schema c'est ajouter des colomn, ajoutes des tables, utiliser le colomn deja dedans , mais en aucun cas supprimer des colomn, ou des tables.

Dans le code pour page, il y a des donnees, bien en const qu'en jsx dure (Si les donnees peuve deja etre gerer par la structure actuel tu dit), ne te confie pas au structure de donnees de la page pour construire le schema tu dois penser comme un pro de la base de donnees concepteur, je veux que tu adapte schema pour que le schema puisse le servire completement, donc tu dois me donnees le code complet de schema, meme avec ce qui reste inchanger (pour copie coller), avec une nouvelle version que la page puisse utiliser dans le future, n'oublie pas de mettre les commentaire pour savoir ce que tu as modifier et met un identifiant que schema a ete modifier pour la page X

Et la structure des donnees doit etres comme si un pro avait fait la conception (reflechi bien a quoi ressemble une diagramme de classe avant de donnees le code) de la base de donnees, et sache que le schema sera aussi utiliser pour generer un diagramme de classe dans le future alors je compte sur toi, avant de donnees le code dit moi ce que tu as compris de ma demande, et dit moi ce que va faire. ATTENTION au erreur typescript, ne met pas de truc dont tu n'est pas sur



Je veux que mon fichier (faire un crud) utilise le schema suivant, ce qu'il ne faut pas toucher dans le ce fichier c'est la GESTION POS, car il marche deja, et suit les memes methodes que dedans, et mets des commentaires



/// vrai 


Je voudrai que tu me dise quelle tables, quelle colomn peu servire a affiche ceci et cela dans la page sans aucune exeption (si il y a des donnees derives dit comment on peu les obtenir)

NB : sache qu'il est pas possible de modifier le schema donc fait avec ce qu'ona , donc tu dois suggerer des solutions directement dans le page front



Je veux que tu me donnee cette page en sachant que les donnees du backend appeller par cette api en piece join sont de meme structure que ce schema sans aucune exeption, donc je veux que la page utilise maintenant de vrai donnees venant de la base de donnees grace a ce api

NB :ajoute des commentaires, pour que tu me dicrit des choses graces a ton analyse d'en haut


Je veux que tu me creer un page appeler ClubEventsPage a exporetr comme ceci : "export default ClubEventsPage;", je veux que cette page me donne un CRUD complet pour evenements, avec un design comme tiktok desktop et mobile


Sans toucher au design, je veux que tu m'aide a remplire code pour ajouter ce qu'il demande a ajouter

MOBILE 

Crée une application mobile basée sur ce schéma de base de données pour un projet événementiel et de gestion de clubs/artistes. Imagine l'application comme une plateforme complète où les utilisateurs peuvent découvrir et participer à des événements, interagir avec des artistes et des clubs, gérer leurs tickets et paiements, et publier des photos et feedbacks.

Utilisateurs :

user : peut suivre des artistes et clubs, réserver des événements, acheter des tickets, laisser des commentaires et des avis, gérer son profil et ses préférences.

artist : peut créer et gérer ses événements, partager des portfolios, recevoir des réservations et collaborations, consulter les feedbacks et statistiques.

club : peut publier des événements, gérer ses tables et réservations, afficher les horaires et fonctionnalités du club, gérer promotions et transactions POS.

admin : peut superviser tous les contenus, approuver des événements, gérer les utilisateurs et les transactions.

Fonctionnalités clés pour le mobile :

Accueil personnalisé : fil d’actualité des événements, artistes et clubs recommandés selon les préférences et la géolocalisation.

Recherche et filtrage : par genre musical, type d’événement, ville, date, popularité, mood, prix.

Événements : création, modification, réservation de tables, achat de tickets, consultation des participants, interaction avec artistes et clubs.

Profil utilisateur : gestion du profil, portefeuille, préférences, historique des participations et transactions, photos uploadées et aimées.

Artistes : gestion de portfolio, planning d’événements, statistiques de popularité et bookings.

Clubs : gestion des tables, horaires d’ouverture, fonctionnalités, réservations, promotions et transactions POS.

Collaboration et messages : chat et suivi des milestones entre clubs et artistes pour organiser des événements.

Notifications et paramétrages : notifications push, e-mail, dark mode, langue et localisation.

Paiements et transactions : intégration des méthodes de paiement, suivi des factures et transactions.

Feedback et photos : consultation et publication de feedbacks, commentaires, likes, upload de photos avec gestion des tags et miniatures.

Design mobile : interface intuitive, responsive pour smartphones, navigation par onglets ou bottom navigation bar, affichage clair des événements avec images et mood, mise en avant des artistes et clubs populaires, accès rapide aux tickets, réservations et portefeuille.

Intégration technique : l’application mobile doit consommer l’API correspondant à ce schéma Drizzle ORM, avec validation côté frontend pour correspondre aux insert schemas (ex : validation date future pour événements, rating 0–5, statuts valides pour participants/invitations). Prévoir un stockage local minimal pour les préférences et données offline.

Schema : 

// D:\Projet\BeBit\bebit - new\shared\schema.ts
import { pgTable, text, serial, integer, boolean, timestamp, decimal, jsonb, primaryKey } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// ======================
// Users table
// ======================
export type UserRole = "user" | "artist" | "club" | "admin";

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  email: text("email").notNull().unique(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  role: text("role", { enum: ["user", "artist", "club", "admin"] }).notNull().default("user"),
  profileImage: text("profile_image"),
  city: text("city").default(""),
  country: text("country").default(""),
  latitude: decimal("latitude", { precision: 10, scale: 7 }),
  longitude: decimal("longitude", { precision: 10, scale: 7 }),
  walletBalance: decimal("wallet_balance", { precision: 10, scale: 2 }).notNull().default("0"),
  isVerified: boolean("is_verified").notNull().default(false),
  phone: text("phone"),
  verificationStatus: text("verification_status", { enum: ["pending", "approved", "rejected"] }),
  verificationDocuments: jsonb("verification_documents").default("[]"),
  notificationsEnabled: boolean("notifications_enabled").notNull().default(true),
  emailNotificationsEnabled: boolean("email_notifications_enabled").notNull().default(true),
  darkMode: boolean("dark_mode").notNull().default(false),
  language: text("language").notNull().default("fr"),
  locationEnabled: boolean("location_enabled").notNull().default(true),
  twoFactorEnabled: boolean("two_factor_enabled").notNull().default(false),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// ======================
// Artists table
// ======================
export const artists = pgTable("artists", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull().unique(),
  displayName: text("display_name").notNull(),
  genre: text("genre").notNull(),
  bio: text("bio"),
  rate: decimal("rate", { precision: 10, scale: 2 }).notNull().default("0"),
  tags: jsonb("tags").notNull().default("[]"),
  popularity: integer("popularity").notNull().default(0),
  socialMedia: jsonb("social_media").default("{}"),
  contact: jsonb("contact").default("{}"),
  location: text("location").default(""),
  rating: decimal("rating", { precision: 3, scale: 1 }).default("0"),
  bookings: integer("bookings").default(0),
});

export const artistPortfolios = pgTable("artist_portfolios", {
  id: serial("id").primaryKey(),
  artistId: integer("artist_id").references(() => artists.id).notNull(),
  image: text("image").notNull(),
  title: text("title").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// ======================
// Clubs table
// ======================
export const clubs = pgTable("clubs", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull().unique(),
  name: text("name").notNull(),
  city: text("city").notNull(),
  country: text("country").notNull(),
  address: text("address"),
  latitude: decimal("latitude", { precision: 10, scale: 7 }),
  longitude: decimal("longitude", { precision: 10, scale: 7 }),
  capacity: integer("capacity").notNull(),
  description: text("description"),
  profileImage: text("profile_image"),
  rating: decimal("rating", { precision: 3, scale: 1 }).notNull().default("0"),
  reviewCount: integer("review_count").notNull().default(0),
  category: text("category").notNull().default("Nightclub"),
  coverImage: text("cover_image"),
  featured: boolean("featured").default(false),
  instagram: text("instagram"),
  website: text("website"),
  openingHours: jsonb("opening_hours").default("{}"),
  features: jsonb("features").default("[]"),
  hasTableReservation: boolean("has_table_reservation").default(false),
});

export const clubLocations = pgTable("club_locations", {
  id: serial("id").primaryKey(),
  clubId: integer("club_id").references(() => clubs.id).notNull(),
  name: text("name").notNull(),
  description: text("description"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const clubTables = pgTable("club_tables", {
  id: serial("id").primaryKey(),
  clubId: integer("club_id").references(() => clubs.id).notNull(),
  name: text("name").notNull(),
  capacity: integer("capacity").notNull(),
  price: decimal("price", { precision: 10, scale: 2 }).notNull(),
  available: boolean("available").notNull().default(true),
  description: text("description"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// ======================
// Events table (MODIFIÉE)
// ======================
export const events = pgTable("events", {
  id: serial("id").primaryKey(),
  // Organisation flexible (peut être club, artiste ou utilisateur)
  organizerType: text("organizer_type", { enum: ["club", "artist", "user"] }).notNull(),
  organizerId: integer("organizer_id").notNull(),
  // Utilisateur qui crée l'événement
  createdBy: integer("created_by").references(() => users.id).notNull(),
 
  title: text("title").notNull(),
  description: text("description"),
  date: timestamp("date").notNull(),
  startTime: text("start_time").notNull(),
  endTime: text("end_time").notNull(),
  location: text("location").notNull(),
  city: text("city").notNull().default(""),
  country: text("country").notNull().default(""),
  latitude: decimal("latitude", { precision: 10, scale: 7 }),
  longitude: decimal("longitude", { precision: 10, scale: 7 }),
  venueName: text("venue_name").notNull(),
  category: text("category").notNull(),
  price: decimal("price", { precision: 10, scale: 2 }).notNull(),
  capacity: integer("capacity").notNull(),
  coverImage: text("cover_image"),
  participantCount: integer("participant_count").notNull().default(0),
  popularity: integer("popularity").notNull().default(0),
  isApproved: boolean("is_approved").notNull().default(false),
  status: text("status", { enum: ["upcoming", "planning", "past", "cancelled"] }).default("planning"),
  mood: text("mood", { enum: ["energetic", "chill", "romantic", "dark", "festive"] }),
  reserveTables: boolean("reserve_tables").default(false),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const eventReservedTables = pgTable("event_reserved_tables", {
  eventId: integer("event_id").references(() => events.id).notNull(),
  tableId: integer("table_id").references(() => clubTables.id).notNull(),
  reservedAt: timestamp("reserved_at").defaultNow().notNull(),
}, (t) => ({
  pk: primaryKey({ columns: [t.eventId, t.tableId] }),
}));

// ======================
// Event Artists junction table
// ======================
export const eventArtists = pgTable("event_artists", {
  eventId: integer("event_id").references(() => events.id).notNull(),
  artistId: integer("artist_id").references(() => artists.id).notNull(),
  fee: decimal("fee", { precision: 10, scale: 2 }),
}, (t) => ({
  pk: primaryKey({ columns: [t.eventId, t.artistId] }),
}));

export const eventParticipants = pgTable("event_participants", {
  eventId: integer("event_id").references(() => events.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  status: text("status", { enum: ["pending", "confirmed", "cancel"] }).notNull().default("pending"),
  joinedAt: timestamp("joined_at").defaultNow().notNull(),
}, (t) => ({
  pk: primaryKey({ columns: [t.eventId, t.userId] }),
}));

// ======================
// Invitations table
// ======================
export const invitations = pgTable("invitations", {
  id: serial("id").primaryKey(),
  eventId: integer("event_id").references(() => events.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  invitedById: integer("invited_by_id").references(() => users.id).notNull(),
  status: text("status", { enum: ["pending", "accepted", "declined", "confirmed", "cancelled", "rejected", "negotiation", "preparation", "completed"] }).notNull().default("pending"),
  progress: integer("progress").default(0),
  invitedAt: timestamp("invited_at").defaultNow().notNull(),
  expectedAttendees: integer("expected_attendees").default(0),
  genre: text("genre"),
  description: text("description"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// ======================
// Tickets table
// ======================
export const tickets = pgTable("tickets", {
  id: serial("id").primaryKey(),
  eventId: integer("event_id").references(() => events.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  ticketTypeId: integer("ticket_type_id").references(() => ticketTypes.id).notNull(),
  price: decimal("price", { precision: 10, scale: 2 }).notNull(),
  purchasedAt: timestamp("purchased_at").defaultNow().notNull(),
  status: text("status", { enum: ["purchased", "used", "refunded"] }).default("purchased"),
});

export const ticketTypes = pgTable("ticketTypes", {
  id: serial("id").primaryKey(),
  eventId: integer("event_id").references(() => events.id).notNull(),
  name: text("name").notNull(),
  price: decimal("price", { precision: 10, scale: 2 }).notNull(),
  capacity: integer("capacity").notNull(),
  description: text("description"),
});

// ======================
// Feedback table
// ======================
export const feedback = pgTable("feedback", {
  id: serial("id").primaryKey(),
  reviewerId: integer("reviewer_id").references(() => users.id).notNull(),
  sourceType: text("source_type", { enum: ["user", "club", "artist", "event"] }).notNull(),
  sourceId: integer("source_id").notNull(),
  title: text("title").notNull(),
  rating: integer("rating").notNull(),
  comment: text("comment").notNull(),
  reply: text("reply"),
  sourceName: text("source_name").notNull(),
  likesCount: integer("likes_count").default(0),
  commentsCount: integer("comments_count").default(0),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const feedbackLikes = pgTable("feedback_likes", {
  feedbackId: integer("feedback_id").references(() => feedback.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  likedAt: timestamp("liked_at").defaultNow().notNull(),
}, (t) => ({
  pk: primaryKey({ columns: [t.feedbackId, t.userId] }),
}));

export const feedbackComments = pgTable("feedback_comments", {
  id: serial("id").primaryKey(),
  feedbackId: integer("feedback_id").references(() => feedback.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  content: text("content").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// ======================
// Photos tables
// ======================
export const photos = pgTable("photos", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  eventId: integer("event_id").references(() => events.id),
  title: text("title").notNull(),
  description: text("description"),
  url: text("url").notNull(),
  thumbnail: text("thumbnail").notNull(),
  tags: jsonb("tags").default("[]"),
  likesCount: integer("likes_count").default(0),
  commentsCount: integer("comments_count").default(0),
  uploadedAt: timestamp("uploaded_at").defaultNow().notNull(),
});

export const photoLikes = pgTable("photo_likes", {
  photoId: integer("photo_id").references(() => photos.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  likedAt: timestamp("liked_at").defaultNow().notNull(),
}, (t) => ({
  pk: primaryKey({ columns: [t.photoId, t.userId] }),
}));

export const photoComments = pgTable("photo_comments", {
  id: serial("id").primaryKey(),
  photoId: integer("photo_id").references(() => photos.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  content: text("content").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// ======================
// Collaboration tables
// ======================
export const collaborationMilestones = pgTable("collaboration_milestones", {
  id: serial("id").primaryKey(),
  invitationId: integer("invitation_id").references(() => invitations.id).notNull(),
  title: text("title").notNull(),
  description: text("description").notNull(),
  status: text("status", { enum: ["pending", "in_progress", "completed"] }).notNull().default("pending"),
  assignedTo: text("assigned_to", { enum: ["artist", "club", "both"] }).notNull(),
  priority: text("priority", { enum: ["low", "medium", "high"] }).notNull().default("medium"),
  dueDate: timestamp("due_date"),
  completedAt: timestamp("completed_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const collaborationMessages = pgTable("collaboration_messages", {
  id: serial("id").primaryKey(),
  invitationId: integer("invitation_id").references(() => invitations.id).notNull(),
  senderType: text("sender_type", { enum: ["club", "artist"] }).notNull(),
  senderId: integer("sender_id").notNull(),
  content: text("content").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// ======================
// Transactions table
// ======================
export const transactions = pgTable("transactions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  amount: decimal("amount", { precision: 10, scale: 2 }).notNull(),
  type: text("type", { enum: ["credit", "debit", "fee", "withdrawal"] }).notNull(),
  status: text("status", { enum: ["completed", "processing", "failed"] }).notNull().default("processing"),
  description: text("description").notNull(),
  reference: text("reference").unique(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// ======================
// Autres tables
// ======================
export const customerProfiles = pgTable("customer_profiles", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull().unique(),
  preferences: jsonb("preferences").default("{}"),
  visitHistory: jsonb("visit_history").default("[]"),
});

export const musicGenres = pgTable("music_genres", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
  description: text("description"),
});

export const drinkTypes = pgTable("drink_types", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  category: text("category").notNull(),
  price: decimal("price", { precision: 10, scale: 2 }),
});

export const customerTags = pgTable("customer_tags", {
  customerId: integer("customer_id").references(() => customerProfiles.id).notNull(),
  tag: text("tag").notNull(),
}, (t) => ({
  pk: primaryKey({ columns: [t.customerId, t.tag] }),
}));

export const promotions = pgTable("promotions", {
  id: serial("id").primaryKey(),
  eventId: integer("event_id").references(() => events.id),
  clubId: integer("club_id").references(() => clubs.id),
  title: text("title").notNull(),
  description: text("description"),
  discountType: text("discount_type", { enum: ["percentage", "fixed"] }).notNull(),
  discountValue: decimal("discount_value", { precision: 5, scale: 2 }).notNull(),
  status: text("status", { enum: ["active", "inactive", "expired"] }).notNull().default("active"),
  channels: jsonb("channels").default("[]"),
  validFrom: timestamp("valid_from").notNull(),
  validTo: timestamp("valid_to").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const paymentMethods = pgTable("payment_methods", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  type: text("type", { enum: ["card", "bank", "mobile"] }).notNull(),
  details: jsonb("details").notNull(),
  isDefault: boolean("is_default").default(false),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const invoices = pgTable("invoices", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  transactionId: integer("transaction_id").references(() => transactions.id),
  amount: decimal("amount", { precision: 10, scale: 2 }).notNull(),
  status: text("status", { enum: ["paid", "pending", "overdue"] }).notNull().default("pending"),
  dueDate: timestamp("due_date"),
  paidAt: timestamp("paid_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// ======================
// POS tables (Employees, Devices, Tables, Orders) → structure S1 (reprise exacte)
// ======================
export const employees = pgTable("employees", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  role: text("role").notNull(),
  pin: text("pin").notNull(),
  status: boolean("status").notNull(),
  deviceId: integer("device_id").references(() => posDevices.id),
  // clubId: integer("club_id").references(() => clubs.id).notNull(),
});

export const posDevices = pgTable("pos_devices", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  location: text("location"),
  status: boolean("status").notNull(),
  lastActive: text("last_active"),
  sales: integer("sales"),
});

export const productCategories = pgTable("product_categories", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  isActive: boolean("is_active").notNull().default(true),
});

export const products = pgTable("products", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  price: integer("price").notNull(),
  categoryId: integer("category_id").references(() => productCategories.id),
  destinations: text("destinations").notNull(),
  isAvailable: boolean("is_available").notNull().default(true),
  imageUrl: text("image_url"),
});

export const posTables = pgTable("pos_tables", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  number: integer("number"),
  area: text("area"),
  capacity: integer("capacity"),
  status: text("status").notNull(),
  currentOrderId: integer("current_order_id"),
});

export const orders = pgTable("orders", {
  id: serial("id").primaryKey(),
  tableId: integer("table_id").references(() => posTables.id),
  customerName: text("customer_name"),
  status: text("status").notNull(),
  total: integer("total").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  paymentMethod: text("payment_method"),
  priority: text("priority"),
  estimatedCompletionTime: timestamp("estimated_completion_time"),
});

export const orderItems = pgTable("order_items", {
  id: serial("id").primaryKey(),
  orderId: integer("order_id").references(() => orders.id),
  productId: integer("product_id").references(() => products.id),
  quantity: integer("quantity").notNull(),
  price: integer("price"),
  notes: text("notes"),
  subtotal: integer("subtotal").notNull(),
  status: text("status"),
  category: text("category"),
  preparationTime: integer("preparation_time"),
});

export const posHistory = pgTable("pos_history", {
  id: serial("id").primaryKey(),
  type: text("type").notNull(),
  description: text("description"),
  userId: integer("user_id").references(() => employees.id),
  userName: text("user_name"),
  userRole: text("user_role"),
  timestamp: timestamp("timestamp").defaultNow().notNull(),
  amount: integer("amount"),
  orderId: integer("order_id").references(() => orders.id),
  tableId: integer("table_id").references(() => posTables.id),
  tableName: text("table_name"),
  details: text("details"),
  status: text("status"),
});

// Méthodes de paiement POS → renommées en pos_payment_methods pour éviter le conflit avec payment_methods (user)
// et pour qu'elles soient utilisables partout dans le POS sans toucher à la table user
export const posPaymentMethods = pgTable("pos_payment_methods", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  value: integer("value").notNull(),
});

// ======================
// Insert Schemas
// ======================
export const insertUserSchema = createInsertSchema(users, {
  role: (schema) => schema.refine((val) => ["user", "artist", "club", "admin"].includes(val), "Rôle invalide"),
});

export const insertArtistSchema = createInsertSchema(artists, {
  socialMedia: (schema) => schema.refine((val) => typeof val === 'object' && val !== null, "Format socialMedia invalide"),
  contact: (schema) => schema.refine((val) => typeof val === 'object' && val !== null, "Format contact invalide"),
  rating: (schema) => schema.min(0).max(5, "Rating entre 0 et 5"),
  bookings: (schema) => schema.min(0, "Bookings non négatif"),
});
export const insertArtistPortfolioSchema = createInsertSchema(artistPortfolios);

export const insertClubSchema = createInsertSchema(clubs, {
  category: (schema) => schema.min(1, "Catégorie requise"),
  openingHours: (schema) => schema.refine((val) => typeof val === 'object', "Format openingHours invalide"),
  features: (schema) => schema.refine((val) => Array.isArray(val), "Features doit être un array"),
});
export const insertClubLocationSchema = createInsertSchema(clubLocations);

export const insertClubTableSchema = createInsertSchema(clubTables, {
  capacity: (schema) => schema.int().min(1, "Capacité minimale 1"),
  price: (schema) => schema.min(0, "Prix non négatif"),
  available: (schema) => schema.default(true),
});

export const insertEventSchema = createInsertSchema(events, {
  // date: (schema) => schema.refine((val) => val > new Date(), "Date doit être future"),
  date: z.coerce.date().refine((val) => val > new Date(), "Date doit être future"),
  startTime: (schema) => schema.regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Format heure invalide"),
  endTime: (schema) => schema.regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Format heure invalide"),
  price: (schema) => schema.min(0, "Prix non négatif"),
  capacity: (schema) => schema.int().min(1, "Capacité minimale 1"),
  reserveTables: (schema) => schema.default(false),
});
export const insertEventArtistSchema = createInsertSchema(eventArtists);

export const insertEventReservedTableSchema = createInsertSchema(eventReservedTables);

export const insertEventParticipantSchema = createInsertSchema(eventParticipants, {
  status: (schema) => schema.refine((val) => ["pending", "confirmed", "cancel"].includes(val), "Status participant invalide"),
});

export const insertInvitationSchema = createInsertSchema(invitations, {
  status: (schema) => schema.refine((val) => 
    ["pending", "accepted", "rejected", "confirmed", "cancelled", "declined", "negotiation", "preparation", "completed"].includes(val), 
    "Statut invalide"
  ),
  progress: (schema) => schema.min(0).max(100, "Progress doit être entre 0 et 100"),
  expectedAttendees: (schema) => schema.int().min(0, "Nombre attendu invalide"),
  genre: (schema) => schema.optional(),
  description: (schema) => schema.optional(),
  invitedById: (schema) => schema.int().min(1, "Invité par requis"),
});

export const insertTicketSchema = createInsertSchema(tickets);
export const insertTicketTypeSchema = createInsertSchema(ticketTypes);

export const insertFeedbackSchema = createInsertSchema(feedback, {
  sourceType: (schema) => schema.refine((val) => ["user", "club", "artist", "event"].includes(val), "Source type invalide"),
  title: (schema) => schema.min(1, "Titre requis"),
  rating: (schema) => schema.int().min(1).max(5, "Rating entre 1 et 5"),
  comment: (schema) => schema.min(10, "Commentaire trop court"),
  reply: (schema) => schema.optional(),
  sourceName: (schema) => schema.min(1, "Nom source requis"),
  likesCount: (schema) => schema.int().min(0, "Likes non négatif"),
  commentsCount: (schema) => schema.int().min(0, "Comments non négatif"),
});

export const insertFeedbackLikeSchema = createInsertSchema(feedbackLikes);

export const insertFeedbackCommentSchema = createInsertSchema(feedbackComments, {
  content: (schema) => schema.min(1, "Commentaire vide invalide"),
});

export const insertCollaborationMilestoneSchema = createInsertSchema(collaborationMilestones, {
  dueDate: z.coerce.date().optional(),  // Handles string ISO dates
  completedAt: z.coerce.date().optional(),  // Handles string ISO dates if provided
  status: (schema) => schema.refine((val) => ["pending", "in_progress", "completed"].includes(val), "Statut milestone invalide"),
  assignedTo: (schema) => schema.refine((val) => ["artist", "club", "both"].includes(val), "Assigné invalide"),
  priority: (schema) => schema.refine((val) => ["low", "medium", "high"].includes(val), "Priorité invalide"),
});

export const insertCollaborationMessageSchema = createInsertSchema(collaborationMessages, {
  senderType: (schema) => schema.refine((val) => ["club", "artist"].includes(val), "Type sender invalide"),
  content: (schema) => schema.min(1, "Message vide invalide").max(2000, "Message trop long"),
});

export const insertTransactionSchema = createInsertSchema(transactions, {
  type: (schema) => schema.refine((val) => ["credit", "debit", "fee", "withdrawal"].includes(val), "Type de transaction invalide"),
  status: (schema) => schema.refine((val) => ["completed", "processing", "failed"].includes(val), "Statut invalide"),
});
export const insertCustomerProfileSchema = createInsertSchema(customerProfiles);
export const insertMusicGenreSchema = createInsertSchema(musicGenres);
export const insertDrinkTypeSchema = createInsertSchema(drinkTypes);
export const insertCustomerTagSchema = createInsertSchema(customerTags);

export const insertPromotionSchema = createInsertSchema(promotions, {
  validFrom: z.coerce.date(),
  validTo: z.coerce.date(),
  discountType: (schema) => schema.refine((val) => ["percentage", "fixed"].includes(val), "Type de discount invalide"),
  status: (schema) => schema.refine((val) => ["active", "inactive", "expired"].includes(val), "Statut invalide"),
  channels: (schema) => schema.refine((val) => Array.isArray(val), "Channels doit être un array"),
});

export const insertPaymentMethodSchema = createInsertSchema(paymentMethods, {
  type: (schema) => schema.refine((val) => ["card", "bank", "mobile"].includes(val), "Type de paiement invalide"),
  details: (schema) => schema.refine((val) => typeof val === 'object' && val !== null, "Format details invalide"),
});

export const insertInvoiceSchema = createInsertSchema(invoices, {
  dueDate: z.coerce.date().optional(),  // Handles string ISO dates
  paidAt: z.coerce.date().optional(),   // Handles string ISO dates if provided
  status: (schema) => schema.refine((val) => ["paid", "pending", "overdue"].includes(val), "Statut de facture invalide"),
});

export const insertPhotoSchema = createInsertSchema(photos, {
  title: (schema) => schema.min(1, "Titre photo requis"),
  url: (schema) => schema.url("URL image invalide"),
  thumbnail: (schema) => schema.url("URL miniature invalide"),
  tags: (schema) => schema.refine((val) => Array.isArray(val), "Tags doit être un array"),
  likesCount: (schema) => schema.int().min(0),
  commentsCount: (schema) => schema.int().min(0),
});

export const insertPhotoLikeSchema = createInsertSchema(photoLikes);

export const insertPhotoCommentSchema = createInsertSchema(photoComments, {
  content: (schema) => schema.min(1, "Commentaire vide invalide").max(2000, "Commentaire trop long"),
});

// POS schemas → style S1 (sans refinements personnalisés)
export const insertEmployeeSchema = createInsertSchema(employees);
export const insertPosDeviceSchema = createInsertSchema(posDevices);
export const insertProductCategorySchema = createInsertSchema(productCategories);
export const insertProductSchema = createInsertSchema(products);
export const insertPosTableSchema = createInsertSchema(posTables);
export const insertOrderSchema = createInsertSchema(orders);
export const insertOrderItemSchema = createInsertSchema(orderItems);
export const insertPosHistorySchema = createInsertSchema(posHistory);
export const insertPosPaymentMethodSchema = createInsertSchema(posPaymentMethods);

// ======================
// Export types
// ======================
export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;
export type Artist = typeof artists.$inferSelect;
export type InsertArtist = z.infer<typeof insertArtistSchema>;
export type ArtistPortfolio = typeof artistPortfolios.$inferSelect;
export type InsertArtistPortfolio = z.infer<typeof insertArtistPortfolioSchema>;

export type Club = typeof clubs.$inferSelect;
export type InsertClub = z.infer<typeof insertClubSchema>;
export type ClubLocation = typeof clubLocations.$inferSelect;
export type InsertClubLocation = z.infer<typeof insertClubLocationSchema>;
export type ClubTable = typeof clubTables.$inferSelect;
export type InsertClubTable = z.infer<typeof insertClubTableSchema>;

export type Event = typeof events.$inferSelect;
export type InsertEvent = z.infer<typeof insertEventSchema>;
export type EventArtist = typeof eventArtists.$inferSelect;
export type InsertEventArtist = z.infer<typeof insertEventArtistSchema>;
export type EventReservedTable = typeof eventReservedTables.$inferSelect;
export type InsertEventReservedTable = z.infer<typeof insertEventReservedTableSchema>;

export type EventParticipant = typeof eventParticipants.$inferSelect;
export type InsertEventParticipant = z.infer<typeof insertEventParticipantSchema>;
export type Invitation = typeof invitations.$inferSelect;
export type InsertInvitation = z.infer<typeof insertInvitationSchema>;
export type Ticket = typeof tickets.$inferSelect;
export type InsertTicket = z.infer<typeof insertTicketSchema>;
export type TicketType = typeof ticketTypes.$inferSelect;
export type InsertTicketType = z.infer<typeof insertTicketTypeSchema>;

export type Feedback = typeof feedback.$inferSelect;
export type InsertFeedback = z.infer<typeof insertFeedbackSchema>;

export type FeedbackLike = typeof feedbackLikes.$inferSelect;
export type InsertFeedbackLike = z.infer<typeof insertFeedbackLikeSchema>;
export type FeedbackComment = typeof feedbackComments.$inferSelect;
export type InsertFeedbackComment = z.infer<typeof insertFeedbackCommentSchema>;

export type Transaction = typeof transactions.$inferSelect;
export type InsertTransaction = z.infer<typeof insertTransactionSchema>;

export type CustomerProfile = typeof customerProfiles.$inferSelect;
export type InsertCustomerProfile = z.infer<typeof insertCustomerProfileSchema>;
export type MusicGenre = typeof musicGenres.$inferSelect;
export type InsertMusicGenre = z.infer<typeof insertMusicGenreSchema>;
export type DrinkType = typeof drinkTypes.$inferSelect;
export type InsertDrinkType = z.infer<typeof insertDrinkTypeSchema>;
export type CustomerTag = typeof customerTags.$inferSelect;
export type InsertCustomerTag = z.infer<typeof insertCustomerTagSchema>;

export type Promotion = typeof promotions.$inferSelect;
export type InsertPromotion = z.infer<typeof insertPromotionSchema>;

export type PaymentMethod = typeof paymentMethods.$inferSelect;
export type InsertPaymentMethod = z.infer<typeof insertPaymentMethodSchema>;
export type Invoice = typeof invoices.$inferSelect;
export type InsertInvoice = z.infer<typeof insertInvoiceSchema>;

export type Photo = typeof photos.$inferSelect;
export type InsertPhoto = z.infer<typeof insertPhotoSchema>;
export type PhotoLike = typeof photoLikes.$inferSelect;
export type InsertPhotoLike = z.infer<typeof insertPhotoLikeSchema>;
export type PhotoComment = typeof photoComments.$inferSelect;
export type InsertPhotoComment = z.infer<typeof insertPhotoCommentSchema>;

export type Employee = typeof employees.$inferSelect;
export type InsertEmployee = z.infer<typeof insertEmployeeSchema>;
export type PosDevice = typeof posDevices.$inferSelect;
export type InsertPosDevice = z.infer<typeof insertPosDeviceSchema>;
export type ProductCategory = typeof productCategories.$inferSelect;
export type InsertProductCategory = z.infer<typeof insertProductCategorySchema>;
export type Product = typeof products.$inferSelect;
export type InsertProduct = z.infer<typeof insertProductSchema>;
export type PosTable = typeof posTables.$inferSelect;
export type InsertPosTable = z.infer<typeof insertPosTableSchema>;
export type Order = typeof orders.$inferSelect;
export type InsertOrder = z.infer<typeof insertOrderSchema>;
export type OrderItem = typeof orderItems.$inferSelect;
export type InsertOrderItem = z.infer<typeof insertOrderItemSchema>;
export type PosHistory = typeof posHistory.$inferSelect;
export type InsertPosHistory = z.infer<typeof insertPosHistorySchema>;
export type PosPaymentMethod = typeof posPaymentMethods.$inferSelect;
export type InsertPosPaymentMethod = z.infer<typeof insertPosPaymentMethodSchema>;

export type CollaborationMilestone = typeof collaborationMilestones.$inferSelect;
export type InsertCollaborationMilestone = z.infer<typeof insertCollaborationMilestoneSchema>;
export type CollaborationMessage = typeof collaborationMessages.$inferSelect;
export type InsertCollaborationMessage = z.infer<typeof insertCollaborationMessageSchema>;


NB : Pour m'aide tu doit me dire dire de rechercher ceci (bout de code exacte que je peu copier <p>Lol</p>) dans le code et le mettre en bas ou au dessus ou le remplacer ou le supprimer


design :

1. Couleurs Primaires (Fond et Texte de Base - 80% de l'usage)

bg-black (#000000) : Fond global (ex. : min-h-screen bg-black), header, modals.
text-white (#FFFFFF) : Titres, textes principaux, labels.
text-gray-400 (#9CA3AF) : Sous-titres, placeholders, infos secondaires (dates, descriptions).

2. Couleurs Secondaires (Bords et Éléments Passifs - 15% de l'usage)

bg-gray-900 (#111827) : Fonds de cartes, sections internes.
bg-gray-800 (#1F2937) : Hovers neutres, fonds de boutons passifs, sections de formulaire.
border-gray-800 / border-gray-700 (#1F2937 / #374151) : Bordures d'inputs, diviseurs, header bottom.

3. Couleurs d'Accent Principale (Actions et Focus - 5% de l'usage)

bg-pink-500 (#EC4899) : Boutons primaires (ex. : submit, créer), états actifs (filtres, badges).
hover:bg-pink-600 (#DB2777) : Hovers sur boutons accents.
text-pink-500 (#EC4899) : Icônes actives, checkboxes, focus (focus:border-pink-500 ou focus:ring-pink-500).

4. Couleurs d'Accent Secondaires (États Spécifiques - Usage modéré)

text-purple-400 (#A78BFA) : Éléments 'Artiste' (badges, tags).
text-blue-400 (#60A5FA) : Éléments 'Club' (badges, sections).
bg-green-500/20 text-green-400 (#4ADE80 translucide) : Succès / À venir (badges statuts).
bg-blue-500/20 text-blue-400 : Planification / En cours.
bg-red-500/20 text-red-400 (#F87171 translucide) : Erreurs / Danger (delete, alerts).
bg-yellow-500/20 text-yellow-400 (#FBBF24 translucide) : Avertissements (non-connecté).
text-gray-300 (#D1D5DB) : Textes neutres sur fonds gris.



Design color :

1. Couleurs Primaires (environ 80 pour cent de l’interface)

Fond noir très profond (#000000)
Utilisé pour couvrir presque tout l’écran. Sert de décor principal pour les pages, l’en-tête et les fenêtres modales.

Texte blanc pur (#FFFFFF)
Employé pour les titres visibles, les textes les plus importants et tout ce qui doit être lu sans effort.

Gris clair atténué (#9CA3AF)
Réservé aux petits détails comme les sous-titres, les zones d’écriture fantômes, les dates ou les descriptions secondaires.

2. Couleurs Secondaires (environ 15 pour cent)

Noir bleuté très sombre (#111827)
Pour les cartes, les sections intérieures et les blocs qui doivent ressortir légèrement sans attirer trop d’attention.

Gris nocturne uniforme (#1F2937)
Utilisé pour les effets de survol neutres, les boutons inactifs ou les zones de formulaire.

Deux tons de gris pour les bordures (#1F2937 et #374151)
Servez-vous du premier pour les bords discrets et du second pour séparer des zones ou souligner le bas d’un en-tête.

3. Couleur d’Accent Principale (environ 5 pour cent)

Rose vif énergique (#EC4899)
La couleur d’action par excellence. Elle habille les boutons importants comme “Créer” ou “Valider”, et montre les états actifs comme les filtres sélectionnés.

Rose un peu plus profond (#DB2777)
Apparaît lors du survol des boutons d’action pour signaler l’interaction.

Rose vif utilisé pour le texte (#EC4899)
Pour les icônes actives, les cases cochées ou l’effet de focus sur les champs.

4. Couleurs d’Accent Secondaires (usage modéré)

Violet clair lumineux (#A78BFA)
Dédié aux éléments liés aux artistes, comme les étiquettes et les petites marques d’identité.

Bleu clair doux (#60A5FA)
Utilisé pour représenter les clubs dans les badges ou certaines sections.

Vert tendre translucide (#4ADE80 avec transparence)
Pour les statuts positifs comme “Succès” ou “À venir”.

Bleu translucide (#60A5FA avec transparence)
Pour les états “Planifié” ou “En cours”.

Rouge translucide (#F87171 avec transparence)
Pour signaler les erreurs, les actions dangereuses ou les suppressions.

Jaune translucide (#FBBF24 avec transparence)
Pour les avertissements tels que l’absence de connexion.

Gris clair adouci (#D1D5DB)
Pour les textes neutres posés sur des fonds gris foncé.


SQL 

SELECT table_name, (xpath('/row/c/text()', xml_count))[1]::text::bigint AS row_count FROM (SELECT table_name, query_to_xml(format('SELECT COUNT(*) AS c FROM %I.%I','public',table_name), false, true, '') AS xml_count FROM information_schema.tables WHERE table_schema='public') AS t;


SELECT json_agg(invitations) AS users_json FROM users;


DO $$DECLARE rec record; output jsonb := '[]'::jsonb; count bigint; data jsonb; BEGIN FOR rec IN SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' LOOP EXECUTE format('SELECT COUNT(*) FROM %I.%I', 'public', rec.table_name) INTO count; IF count > 0 THEN EXECUTE format('SELECT json_agg(row_to_json(t)) FROM %I.%I t', 'public', rec.table_name) INTO data; output := output || jsonb_build_object('table_name', rec.table_name, 'row_count', count, 'rows', data); END IF; END LOOP; RAISE NOTICE '%', jsonb_pretty(output); END $$;


DO $$DECLARE r RECORD; BEGIN FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname='public') LOOP EXECUTE 'TRUNCATE TABLE "' || r.tablename || '" RESTART IDENTITY CASCADE'; END LOOP; END$$;


const Users = {
  id: 1,
  username: "Tolotra",
  password: "pass123",
  email: "club@madagascar.mg",
  firstName: "Tolotra",
  lastName: "Ravelo",
  role: "club",
  profileImage: "https://images.unsplash.com/photo-1563841930606-67e2bce48b78?w=400&h=400&fit=crop",
  city: "Antananarivo",
  country: "Madagascar",
  latitude: "-18.8792",
  longitude: "47.5079",
  walletBalance: "1000.00",
  isVerified: true,
  phone: "+261341234567",
  verificationStatus: "approved",
  verificationDocuments: [],
  notificationsEnabled: true,
  emailNotificationsEnabled: true,
  darkMode: false,
  language: "fr",
  locationEnabled: true,
  twoFactorEnabled: false
};




Crée une application web mobile-first nommée Bebti, dédiée au divertissement nocturne et à la gestion d'événements dans les clubs. Elle doit permettre aux utilisateurs de réserver des tables, acheter des tickets, interagir avec des artistes, recevoir des promotions et laisser des avis. Le système comporte quatre types d’utilisateurs : simple utilisateur, artiste, club et administrateur.

Objectifs principaux de l’application :

Réservation d’événements et de tables en club

Gestion des artistes avec portfolios, genres musicaux, et performances

Publication et gestion d’événements par les clubs et artistes

Interaction sociale (likes, commentaires, feedback, photos partagés)

Gestion de promotions, factures, méthodes de paiement et transactions

Gestion POS pour les clubs (produits, commandes, tables, employés, etc.)

Technologies recommandées :

Backend : Node.js avec TypeScript, NestJS ou Express

Base de données : PostgreSQL

ORM : Drizzle ORM

Frontend : React + Next.js ou Mobile App avec React Native

Authentification : JWT + 2FA optionnel

Stockage fichiers : Cloud (S3, Supabase storage ou autre service)

Fonctionnalités clés selon modules :

Utilisateurs : Inscription, connexion, gestion profil, préférences, wallet, géolocalisation, vérification

Clubs : Créer un profil, gérer leur emplacement, tables, événements, promotions, POS

Artistes : Créer un profil, portfolios, gérer leurs métriques

Événements : Création, engagement, participation, tickets, tables réservées, invitations

Interaction sociale : Feedback, likes, commentaires, photos partagées

Finances : Transactions, facturation, moyens de paiement

POS Club : Gestion tables, commandes, employés, paiements, historique

Utilise le schéma des tables suivantes pour générer la structure des données et les relations :
(inclus une copie complète du JSON des tables)

L’application doit également inclure :

Une interface d’administration pour gérer les utilisateurs, artistes, clubs, événements, feedback, et transactions.

Un tableau de bord utilisateur personnalisé selon le rôle.

Des intégrations pour notifications push, email, et un système de message interne (collaboration_messages pour les clubs/artistes).

Mode dark et multilingue.

Chaque modèle doit respecter les relations FK du schéma.

[
  {
    "table": "users",
    "columns": {
      "id": "serial PK",
      "username": "text unique",
      "password": "text",
      "email": "text unique",
      "firstName": "text",
      "lastName": "text",
      "role": "enum(user, artist, club, admin)",
      "profileImage": "text",
      "city": "text",
      "country": "text",
      "latitude": "decimal(10, 7)",
      "longitude": "decimal(10, 7)",
      "walletBalance": "decimal(10, 2)",
      "isVerified": "boolean",
      "phone": "text",
      "verificationStatus": "enum(pending, approved, rejected)",
      "verificationDocuments": "jsonb",
      "notificationsEnabled": "boolean",
      "emailNotificationsEnabled": "boolean",
      "darkMode": "boolean",
      "language": "text",
      "locationEnabled": "boolean",
      "twoFactorEnabled": "boolean",
      "createdAt": "timestamp"
    },
    "relations": {}
  },
  {
    "table": "artists",
    "columns": {
      "id": "serial PK",
      "userId": "integer FK users.id unique",
      "displayName": "text",
      "genre": "text",
      "bio": "text",
      "rate": "decimal(10, 2)",
      "tags": "jsonb",
      "popularity": "integer",
      "socialMedia": "jsonb",
      "contact": "jsonb",
      "location": "text",
      "rating": "decimal(3, 1)",
      "bookings": "integer"
    },
    "relations": {
      "userId": "users.id"
    }
  },
  {
    "table": "artist_portfolios",
    "columns": {
      "id": "serial PK",
      "artistId": "integer FK artists.id",
      "image": "text",
      "title": "text",
      "createdAt": "timestamp"
    },
    "relations": {
      "artistId": "artists.id"
    }
  },
  {
    "table": "clubs",
    "columns": {
      "id": "serial PK",
      "userId": "integer FK users.id unique",
      "name": "text",
      "city": "text",
      "country": "text",
      "address": "text",
      "latitude": "decimal(10, 7)",
      "longitude": "decimal(10, 7)",
      "capacity": "integer",
      "description": "text",
      "profileImage": "text",
      "rating": "decimal(3, 1)",
      "reviewCount": "integer",
      "category": "text",
      "coverImage": "text",
      "featured": "boolean",
      "instagram": "text",
      "website": "text",
      "openingHours": "jsonb",
      "features": "jsonb",
      "hasTableReservation": "boolean"
    },
    "relations": {
      "userId": "users.id"
    }
  },
  {
    "table": "club_locations",
    "columns": {
      "id": "serial PK",
      "clubId": "integer FK clubs.id",
      "name": "text",
      "description": "text",
      "createdAt": "timestamp",
      "updatedAt": "timestamp"
    },
    "relations": {
      "clubId": "clubs.id"
    }
  },
  {
    "table": "club_tables",
    "columns": {
      "id": "serial PK",
      "clubId": "integer FK clubs.id",
      "name": "text",
      "capacity": "integer",
      "price": "decimal(10, 2)",
      "available": "boolean",
      "description": "text",
      "createdAt": "timestamp"
    },
    "relations": {
      "clubId": "clubs.id"
    }
  },
  {
    "table": "events",
    "columns": {
      "id": "serial PK",
      "organizerType": "enum(club, artist, user)",
      "organizerId": "integer",
      "createdBy": "integer FK users.id",
      "title": "text",
      "description": "text",
      "date": "timestamp",
      "startTime": "text",
      "endTime": "text",
      "location": "text",
      "city": "text",
      "country": "text",
      "latitude": "decimal(10, 7)",
      "longitude": "decimal(10, 7)",
      "venueName": "text",
      "category": "text",
      "price": "decimal(10, 2)",
      "capacity": "integer",
      "coverImage": "text",
      "participantCount": "integer",
      "popularity": "integer",
      "isApproved": "boolean",
      "status": "enum(upcoming, planning, past, cancelled)",
      "mood": "enum(energetic, chill, romantic, dark, festive)",
      "reserveTables": "boolean",
      "createdAt": "timestamp"
    },
    "relations": {
      "createdBy": "users.id"
    }
  },
  {
    "table": "event_reserved_tables",
    "columns": {
      "eventId": "integer FK events.id",
      "tableId": "integer FK club_tables.id",
      "reservedAt": "timestamp"
    },
    "relations": {
      "eventId": "events.id",
      "tableId": "club_tables.id"
    }
  },
  {
    "table": "event_artists",
    "columns": {
      "eventId": "integer FK events.id",
      "artistId": "integer FK artists.id",
      "fee": "decimal(10, 2)"
    },
    "relations": {
      "eventId": "events.id",
      "artistId": "artists.id"
    }
  },
  {
    "table": "event_participants",
    "columns": {
      "eventId": "integer FK events.id",
      "userId": "integer FK users.id",
      "status": "enum(pending, confirmed, cancel)",
      "joinedAt": "timestamp"
    },
    "relations": {
      "eventId": "events.id",
      "userId": "users.id"
    }
  },
  {
    "table": "invitations",
    "columns": {
      "id": "serial PK",
      "eventId": "integer FK events.id",
      "userId": "integer FK users.id",
      "invitedById": "integer FK users.id",
      "status": "enum(pending, accepted, declined, confirmed, cancelled, rejected, negotiation, preparation, completed)",
      "progress": "integer",
      "invitedAt": "timestamp",
      "expectedAttendees": "integer",
      "genre": "text",
      "description": "text",
      "createdAt": "timestamp"
    },
    "relations": {
      "eventId": "events.id",
      "userId": "users.id",
      "invitedById": "users.id"
    }
  },
  {
    "table": "tickets",
    "columns": {
      "id": "serial PK",
      "eventId": "integer FK events.id",
      "userId": "integer FK users.id",
      "ticketTypeId": "integer FK ticketTypes.id",
      "price": "decimal(10, 2)",
      "purchasedAt": "timestamp",
      "status": "enum(purchased, used, refunded)"
    },
    "relations": {
      "eventId": "events.id",
      "userId": "users.id",
      "ticketTypeId": "ticketTypes.id"
    }
  },
  {
    "table": "ticketTypes",
    "columns": {
      "id": "serial PK",
      "eventId": "integer FK events.id",
      "name": "text",
      "price": "decimal(10, 2)",
      "capacity": "integer",
      "description": "text"
    },
    "relations": {
      "eventId": "events.id"
    }
  },
  {
    "table": "feedback",
    "columns": {
      "id": "serial PK",
      "reviewerId": "integer FK users.id",
      "sourceType": "enum(user, club, artist, event)",
      "sourceId": "integer",
      "title": "text",
      "rating": "integer",
      "comment": "text",
      "reply": "text",
      "sourceName": "text",
      "likesCount": "integer",
      "commentsCount": "integer",
      "createdAt": "timestamp"
    },
    "relations": {
      "reviewerId": "users.id"
    }
  },
  {
    "table": "feedback_likes",
    "columns": {
      "feedbackId": "integer FK feedback.id",
      "userId": "integer FK users.id",
      "likedAt": "timestamp"
    },
    "relations": {
      "feedbackId": "feedback.id",
      "userId": "users.id"
    }
  },
  {
    "table": "feedback_comments",
    "columns": {
      "id": "serial PK",
      "feedbackId": "integer FK feedback.id",
      "userId": "integer FK users.id",
      "content": "text",
      "createdAt": "timestamp"
    },
    "relations": {
      "feedbackId": "feedback.id",
      "userId": "users.id"
    }
  },
  {
    "table": "photos",
    "columns": {
      "id": "serial PK",
      "userId": "integer FK users.id",
      "eventId": "integer FK events.id",
      "title": "text",
      "description": "text",
      "url": "text",
      "thumbnail": "text",
      "tags": "jsonb",
      "likesCount": "integer",
      "commentsCount": "integer",
      "uploadedAt": "timestamp"
    },
    "relations": {
      "userId": "users.id",
      "eventId": "events.id"
    }
  },
  {
    "table": "photo_likes",
    "columns": {
      "photoId": "integer FK photos.id",
      "userId": "integer FK users.id",
      "likedAt": "timestamp"
    },
    "relations": {
      "photoId": "photos.id",
      "userId": "users.id"
    }
  },
  {
    "table": "photo_comments",
    "columns": {
      "id": "serial PK",
      "photoId": "integer FK photos.id",
      "userId": "integer FK users.id",
      "content": "text",
      "createdAt": "timestamp"
    },
    "relations": {
      "photoId": "photos.id",
      "userId": "users.id"
    }
  },
  {
    "table": "collaboration_milestones",
    "columns": {
      "id": "serial PK",
      "invitationId": "integer FK invitations.id",
      "title": "text",
      "description": "text",
      "status": "enum(pending, in_progress, completed)",
      "assignedTo": "enum(artist, club, both)",
      "priority": "enum(low, medium, high)",
      "dueDate": "timestamp",
      "completedAt": "timestamp",
      "createdAt": "timestamp"
    },
    "relations": {
      "invitationId": "invitations.id"
    }
  },
  {
    "table": "collaboration_messages",
    "columns": {
      "id": "serial PK",
      "invitationId": "integer FK invitations.id",
      "senderType": "enum(club, artist)",
      "senderId": "integer",
      "content": "text",
      "createdAt": "timestamp"
    },
    "relations": {
      "invitationId": "invitations.id"
    }
  },
  {
    "table": "transactions",
    "columns": {
      "id": "serial PK",
      "userId": "integer FK users.id",
      "amount": "decimal(10, 2)",
      "type": "enum(credit, debit, fee, withdrawal)",
      "status": "enum(completed, processing, failed)",
      "description": "text",
      "reference": "text unique",
      "createdAt": "timestamp"
    },
    "relations": {
      "userId": "users.id"
    }
  },
  {
    "table": "customer_profiles",
    "columns": {
      "id": "serial PK",
      "userId": "integer FK users.id unique",
      "preferences": "jsonb",
      "visitHistory": "jsonb"
    },
    "relations": {
      "userId": "users.id"
    }
  },
  {
    "table": "music_genres",
    "columns": {
      "id": "serial PK",
      "name": "text unique",
      "description": "text"
    },
    "relations": {}
  },
  {
    "table": "drink_types",
    "columns": {
      "id": "serial PK",
      "name": "text",
      "category": "text",
      "price": "decimal(10, 2)"
    },
    "relations": {}
  },
  {
    "table": "customer_tags",
    "columns": {
      "customerId": "integer FK customer_profiles.id",
      "tag": "text"
    },
    "relations": {
      "customerId": "customer_profiles.id"
    }
  },
  {
    "table": "promotions",
    "columns": {
      "id": "serial PK",
      "eventId": "integer FK events.id",
      "clubId": "integer FK clubs.id",
      "title": "text",
      "description": "text",
      "discountType": "enum(percentage, fixed)",
      "discountValue": "decimal(5, 2)",
      "status": "enum(active, inactive, expired)",
      "channels": "jsonb",
      "validFrom": "timestamp",
      "validTo": "timestamp",
      "createdAt": "timestamp"
    },
    "relations": {
      "eventId": "events.id",
      "clubId": "clubs.id"
    }
  },
  {
    "table": "payment_methods",
    "columns": {
      "id": "serial PK",
      "userId": "integer FK users.id",
      "type": "enum(card, bank, mobile)",
      "details": "jsonb",
      "isDefault": "boolean",
      "createdAt": "timestamp"
    },
    "relations": {
      "userId": "users.id"
    }
  },
  {
    "table": "invoices",
    "columns": {
      "id": "serial PK",
      "userId": "integer FK users.id",
      "transactionId": "integer FK transactions.id",
      "amount": "decimal(10, 2)",
      "status": "enum(paid, pending, overdue)",
      "dueDate": "timestamp",
      "paidAt": "timestamp",
      "createdAt": "timestamp"
    },
    "relations": {
      "userId": "users.id",
      "transactionId": "transactions.id"
    }
  },
  {
    "table": "employees",
    "columns": {
      "id": "serial PK",
      "name": "text",
      "role": "text",
      "pin": "text",
      "status": "boolean",
      "deviceId": "integer FK pos_devices.id"
    },
    "relations": {
      "deviceId": "pos_devices.id"
    }
  },
  {
    "table": "pos_devices",
    "columns": {
      "id": "serial PK",
      "name": "text",
      "location": "text",
      "status": "boolean",
      "lastActive": "text",
      "sales": "integer"
    },
    "relations": {}
  },
  {
    "table": "product_categories",
    "columns": {
      "id": "serial PK",
      "name": "text",
      "description": "text",
      "isActive": "boolean"
    },
    "relations": {}
  },
  {
    "table": "products",
    "columns": {
      "id": "serial PK",
      "name": "text",
      "description": "text",
      "price": "integer",
      "categoryId": "integer FK product_categories.id",
      "destinations": "text",
      "isAvailable": "boolean",
      "imageUrl": "text"
    },
    "relations": {
      "categoryId": "product_categories.id"
    }
  },
  {
    "table": "pos_tables",
    "columns": {
      "id": "serial PK",
      "name": "text",
      "number": "integer",
      "area": "text",
      "capacity": "integer",
      "status": "text",
      "currentOrderId": "integer"
    },
    "relations": {}
  },
  {
    "table": "orders",
    "columns": {
      "id": "serial PK",
      "tableId": "integer FK pos_tables.id",
      "customerName": "text",
      "status": "text",
      "total": "integer",
      "createdAt": "timestamp",
      "updatedAt": "timestamp",
      "paymentMethod": "text",
      "priority": "text",
      "estimatedCompletionTime": "timestamp"
    },
    "relations": {
      "tableId": "pos_tables.id"
    }
  },
  {
    "table": "order_items",
    "columns": {
      "id": "serial PK",
      "orderId": "integer FK orders.id",
      "productId": "integer FK products.id",
      "quantity": "integer",
      "price": "integer",
      "notes": "text",
      "subtotal": "integer",
      "status": "text",
      "category": "text",
      "preparationTime": "integer"
    },
    "relations": {
      "orderId": "orders.id",
      "productId": "products.id"
    }
  },
  {
    "table": "pos_history",
    "columns": {
      "id": "serial PK",
      "type": "text",
      "description": "text",
      "userId": "integer FK employees.id",
      "userName": "text",
      "userRole": "text",
      "timestamp": "timestamp",
      "amount": "integer",
      "orderId": "integer FK orders.id",
      "tableId": "integer FK pos_tables.id",
      "tableName": "text",
      "details": "text",
      "status": "text"
    },
    "relations": {
      "userId": "employees.id",
      "orderId": "orders.id",
      "tableId": "pos_tables.id"
    }
  },
  {
    "table": "pos_payment_methods",
    "columns": {
      "id": "serial PK",
      "name": "text",
      "value": "integer"
    },
    "relations": {}
  }
]


CREATE DATABASE copie_bebit WITH TEMPLATE bebit OWNER postgres;

